23:48 < peterbjo1nx> if reader fails on (n) that means it will take (N - 1) before n is rewritten again
23:48 < peterbjo1nx> where n is the buffer index and N the number of buffers
23:49 -!- fornazi [~oiees@177.194.75.69] has quit [Quit: Leaving]
23:51 -!- xenos1984 [~quassel@43-29-196-88.dyn.estpak.ee] has quit [Remote host closed the connection]
23:55 -!- divine [~divine@2001:470:8247:1::30] has joined #osdev
23:59 -!- nw [~Adium@tyre.if.org] has joined #osdev
Day changed to 19 Feb 2015
00:01 -!- gerryg_ [~gerryg@1.136.96.178] has joined #osdev
00:06 -!- rhcake [~rhcake@81.198.173.63] has quit [Quit: rhcake]
00:08 < peterbjo1nx> what if i use sysv message queues
00:08 < mrvn> then you are using sysv message queues
00:10 < peterbjo1nx> if i implement it in such a way that it will fill a queue for each client, simply skipping 
                     the queue fill for full queues 
00:11 -!- hidark [~hidark@90.174.2.5] has joined #osdev
00:11 < mrvn> then you have a bunch of obsolete data in the queue when the reader is slow
00:11 < mrvn> and no data when the updater crashed
00:12 < peterbjo1nx> hmm, i think i might just accept that last part
00:12 < peterbjo1nx> if i use posix mq's i can set max message count to 1
00:13 < mrvn> then you can just use IP multicast or broadcast to have the same effect
00:13 < peterbjo1nx> that way no race conditions, no deadlocks and no data that is more obsolete than is 
                     necessary
00:13 < mrvn> you might not want count 1 because then any smallist hickup means lost data
00:14 < peterbjo1nx> lost data is not an issue
00:14 -!- dallinac [~dallinac@c-67-182-208-98.hsd1.ut.comcast.net] has quit [Ping timeout: 244 seconds]
00:14 < peterbjo1nx> fresh data is important, not getting all data
00:14 < mrvn> well, make up your mind what you need and then the solution will be easy.
00:14 < peterbjo1nx> still, the data is only guaranteed to be as fresh as the last read
00:14 < peterbjo1nx> hmm
00:16 -!- Philpax [~Philpax@175.33.19.148] has quit [Quit: Leaving]
00:18 < peterbjo1nx> if i use a size of 1 and do two successive reads seperated by a small delay it should be 
                     pretty fresh every time

